-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Shopify.Query exposing (..)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.Operation exposing (RootMutation, RootQuery, RootSubscription)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Json.Decode as Decode exposing (Decoder)
import Shopify.Enum.ArticleSortKeys
import Shopify.Enum.BlogSortKeys
import Shopify.Enum.CollectionSortKeys
import Shopify.Enum.LocationSortKeys
import Shopify.Enum.PageSortKeys
import Shopify.Enum.ProductSortKeys
import Shopify.InputObject
import Shopify.Interface
import Shopify.Object
import Shopify.Scalar
import Shopify.ScalarCodecs
import Shopify.Union


type alias ArticlesOptionalArguments =
    { first : OptionalArgument Int
    , after : OptionalArgument String
    , last : OptionalArgument Int
    , before : OptionalArgument String
    , reverse : OptionalArgument Bool
    , sortKey : OptionalArgument Shopify.Enum.ArticleSortKeys.ArticleSortKeys
    , query : OptionalArgument String
    }


{-| List of the shop's articles.

  - first - Returns up to the first `n` elements from the list.
  - after - Returns the elements that come after the specified cursor.
  - last - Returns up to the last `n` elements from the list.
  - before - Returns the elements that come before the specified cursor.
  - reverse - Reverse the order of the underlying list.
  - sortKey - Sort the underlying list by the given key.
  - query - Supported filter parameters:
  - `author`
  - `blog_title`
  - `created_at`
  - `tag`
  - `tag_not`
  - `updated_at`

See the detailed [search syntax](https://shopify.dev/api/usage/search-syntax)
for more information about using filters.

-}
articles :
    (ArticlesOptionalArguments -> ArticlesOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.ArticleConnection
    -> SelectionSet decodesTo RootQuery
articles fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, after = Absent, last = Absent, before = Absent, reverse = Absent, sortKey = Absent, query = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "reverse" filledInOptionals____.reverse Encode.bool, Argument.optional "sortKey" filledInOptionals____.sortKey (Encode.enum Shopify.Enum.ArticleSortKeys.toString), Argument.optional "query" filledInOptionals____.query Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "articles" optionalArgs____ object____ Basics.identity


type alias BlogOptionalArguments =
    { id : OptionalArgument Shopify.ScalarCodecs.Id
    , handle : OptionalArgument String
    }


{-| Fetch a specific `Blog` by one of its unique attributes.

  - id - The ID of the `Blog`.
  - handle - The handle of the `Blog`.

-}
blog :
    (BlogOptionalArguments -> BlogOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.Blog
    -> SelectionSet (Maybe decodesTo) RootQuery
blog fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, handle = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Shopify.ScalarCodecs.codecs |> Shopify.Scalar.unwrapEncoder .codecId), Argument.optional "handle" filledInOptionals____.handle Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "blog" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias BlogByHandleRequiredArguments =
    { handle : String }


{-| Find a blog by its handle.

  - handle - The handle of the blog.

-}
blogByHandle :
    BlogByHandleRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.Blog
    -> SelectionSet (Maybe decodesTo) RootQuery
blogByHandle requiredArgs____ object____ =
    Object.selectionForCompositeField "blogByHandle" [ Argument.required "handle" requiredArgs____.handle Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias BlogsOptionalArguments =
    { first : OptionalArgument Int
    , after : OptionalArgument String
    , last : OptionalArgument Int
    , before : OptionalArgument String
    , reverse : OptionalArgument Bool
    , sortKey : OptionalArgument Shopify.Enum.BlogSortKeys.BlogSortKeys
    , query : OptionalArgument String
    }


{-| List of the shop's blogs.

  - first - Returns up to the first `n` elements from the list.
  - after - Returns the elements that come after the specified cursor.
  - last - Returns up to the last `n` elements from the list.
  - before - Returns the elements that come before the specified cursor.
  - reverse - Reverse the order of the underlying list.
  - sortKey - Sort the underlying list by the given key.
  - query - Supported filter parameters:
  - `created_at`
  - `handle`
  - `title`
  - `updated_at`

See the detailed [search syntax](https://shopify.dev/api/usage/search-syntax)
for more information about using filters.

-}
blogs :
    (BlogsOptionalArguments -> BlogsOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.BlogConnection
    -> SelectionSet decodesTo RootQuery
blogs fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, after = Absent, last = Absent, before = Absent, reverse = Absent, sortKey = Absent, query = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "reverse" filledInOptionals____.reverse Encode.bool, Argument.optional "sortKey" filledInOptionals____.sortKey (Encode.enum Shopify.Enum.BlogSortKeys.toString), Argument.optional "query" filledInOptionals____.query Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "blogs" optionalArgs____ object____ Basics.identity


type alias CartRequiredArguments =
    { id : Shopify.ScalarCodecs.Id }


{-| Find a cart by its ID.

  - id - The id of the cart.

-}
cart :
    CartRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.Cart
    -> SelectionSet (Maybe decodesTo) RootQuery
cart requiredArgs____ object____ =
    Object.selectionForCompositeField "cart" [ Argument.required "id" requiredArgs____.id (Shopify.ScalarCodecs.codecs |> Shopify.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias CollectionOptionalArguments =
    { id : OptionalArgument Shopify.ScalarCodecs.Id
    , handle : OptionalArgument String
    }


{-| Fetch a specific `Collection` by one of its unique attributes.

  - id - The ID of the `Collection`.
  - handle - The handle of the `Collection`.

-}
collection :
    (CollectionOptionalArguments -> CollectionOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.Collection
    -> SelectionSet (Maybe decodesTo) RootQuery
collection fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, handle = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Shopify.ScalarCodecs.codecs |> Shopify.Scalar.unwrapEncoder .codecId), Argument.optional "handle" filledInOptionals____.handle Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "collection" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias CollectionByHandleRequiredArguments =
    { handle : String }


{-| Find a collection by its handle.

  - handle - The handle of the collection.

-}
collectionByHandle :
    CollectionByHandleRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.Collection
    -> SelectionSet (Maybe decodesTo) RootQuery
collectionByHandle requiredArgs____ object____ =
    Object.selectionForCompositeField "collectionByHandle" [ Argument.required "handle" requiredArgs____.handle Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias CollectionsOptionalArguments =
    { first : OptionalArgument Int
    , after : OptionalArgument String
    , last : OptionalArgument Int
    , before : OptionalArgument String
    , reverse : OptionalArgument Bool
    , sortKey : OptionalArgument Shopify.Enum.CollectionSortKeys.CollectionSortKeys
    , query : OptionalArgument String
    }


{-| List of the shopâ€™s collections.

  - first - Returns up to the first `n` elements from the list.
  - after - Returns the elements that come after the specified cursor.
  - last - Returns up to the last `n` elements from the list.
  - before - Returns the elements that come before the specified cursor.
  - reverse - Reverse the order of the underlying list.
  - sortKey - Sort the underlying list by the given key.
  - query - Supported filter parameters:
  - `collection_type`
  - `title`
  - `updated_at`

See the detailed [search syntax](https://shopify.dev/api/usage/search-syntax)
for more information about using filters.

-}
collections :
    (CollectionsOptionalArguments -> CollectionsOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.CollectionConnection
    -> SelectionSet decodesTo RootQuery
collections fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, after = Absent, last = Absent, before = Absent, reverse = Absent, sortKey = Absent, query = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "reverse" filledInOptionals____.reverse Encode.bool, Argument.optional "sortKey" filledInOptionals____.sortKey (Encode.enum Shopify.Enum.CollectionSortKeys.toString), Argument.optional "query" filledInOptionals____.query Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "collections" optionalArgs____ object____ Basics.identity


type alias CustomerRequiredArguments =
    { customerAccessToken : String }


{-| Find a customer by its access token.

  - customerAccessToken - The customer access token.

-}
customer :
    CustomerRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.Customer
    -> SelectionSet (Maybe decodesTo) RootQuery
customer requiredArgs____ object____ =
    Object.selectionForCompositeField "customer" [ Argument.required "customerAccessToken" requiredArgs____.customerAccessToken Encode.string ] object____ (Basics.identity >> Decode.nullable)


{-| Returns the localized experiences configured for the shop.
-}
localization :
    SelectionSet decodesTo Shopify.Object.Localization
    -> SelectionSet decodesTo RootQuery
localization object____ =
    Object.selectionForCompositeField "localization" [] object____ Basics.identity


type alias LocationsOptionalArguments =
    { first : OptionalArgument Int
    , after : OptionalArgument String
    , last : OptionalArgument Int
    , before : OptionalArgument String
    , reverse : OptionalArgument Bool
    , sortKey : OptionalArgument Shopify.Enum.LocationSortKeys.LocationSortKeys
    , near : OptionalArgument Shopify.InputObject.GeoCoordinateInput
    }


{-| List of the shop's locations that support in-store pickup.

When sorting by distance, you must specify a location via the `near` argument.

  - first - Returns up to the first `n` elements from the list.
  - after - Returns the elements that come after the specified cursor.
  - last - Returns up to the last `n` elements from the list.
  - before - Returns the elements that come before the specified cursor.
  - reverse - Reverse the order of the underlying list.
  - sortKey - Sort the underlying list by the given key.
  - near - Used to sort results based on proximity to the provided location.

-}
locations :
    (LocationsOptionalArguments -> LocationsOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.LocationConnection
    -> SelectionSet decodesTo RootQuery
locations fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, after = Absent, last = Absent, before = Absent, reverse = Absent, sortKey = Absent, near = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "reverse" filledInOptionals____.reverse Encode.bool, Argument.optional "sortKey" filledInOptionals____.sortKey (Encode.enum Shopify.Enum.LocationSortKeys.toString), Argument.optional "near" filledInOptionals____.near Shopify.InputObject.encodeGeoCoordinateInput ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "locations" optionalArgs____ object____ Basics.identity


type alias MenuRequiredArguments =
    { handle : String }


{-| A storefront menu.

  - handle - Returns a storefront menu by the specified handle.

-}
menu :
    MenuRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.Menu
    -> SelectionSet (Maybe decodesTo) RootQuery
menu requiredArgs____ object____ =
    Object.selectionForCompositeField "menu" [ Argument.required "handle" requiredArgs____.handle Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias NodeRequiredArguments =
    { id : Shopify.ScalarCodecs.Id }


{-| Returns a specific node by ID.

  - id - The ID of the Node to return.

-}
node :
    NodeRequiredArguments
    -> SelectionSet decodesTo Shopify.Interface.Node
    -> SelectionSet (Maybe decodesTo) RootQuery
node requiredArgs____ object____ =
    Object.selectionForCompositeField "node" [ Argument.required "id" requiredArgs____.id (Shopify.ScalarCodecs.codecs |> Shopify.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.nullable)


type alias NodesRequiredArguments =
    { ids : List Shopify.ScalarCodecs.Id }


{-| Returns the list of nodes with the given IDs.

  - ids - The IDs of the Nodes to return.

-}
nodes :
    NodesRequiredArguments
    -> SelectionSet decodesTo Shopify.Interface.Node
    -> SelectionSet (List (Maybe decodesTo)) RootQuery
nodes requiredArgs____ object____ =
    Object.selectionForCompositeField "nodes" [ Argument.required "ids" requiredArgs____.ids ((Shopify.ScalarCodecs.codecs |> Shopify.Scalar.unwrapEncoder .codecId) |> Encode.list) ] object____ (Basics.identity >> Decode.nullable >> Decode.list)


type alias PageOptionalArguments =
    { id : OptionalArgument Shopify.ScalarCodecs.Id
    , handle : OptionalArgument String
    }


{-| Fetch a specific `Page` by one of its unique attributes.

  - id - The ID of the `Page`.
  - handle - The handle of the `Page`.

-}
page :
    (PageOptionalArguments -> PageOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.Page
    -> SelectionSet (Maybe decodesTo) RootQuery
page fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, handle = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Shopify.ScalarCodecs.codecs |> Shopify.Scalar.unwrapEncoder .codecId), Argument.optional "handle" filledInOptionals____.handle Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "page" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias PageByHandleRequiredArguments =
    { handle : String }


{-| Find a page by its handle.

  - handle - The handle of the page.

-}
pageByHandle :
    PageByHandleRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.Page
    -> SelectionSet (Maybe decodesTo) RootQuery
pageByHandle requiredArgs____ object____ =
    Object.selectionForCompositeField "pageByHandle" [ Argument.required "handle" requiredArgs____.handle Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias PagesOptionalArguments =
    { first : OptionalArgument Int
    , after : OptionalArgument String
    , last : OptionalArgument Int
    , before : OptionalArgument String
    , reverse : OptionalArgument Bool
    , sortKey : OptionalArgument Shopify.Enum.PageSortKeys.PageSortKeys
    , query : OptionalArgument String
    }


{-| List of the shop's pages.

  - first - Returns up to the first `n` elements from the list.
  - after - Returns the elements that come after the specified cursor.
  - last - Returns up to the last `n` elements from the list.
  - before - Returns the elements that come before the specified cursor.
  - reverse - Reverse the order of the underlying list.
  - sortKey - Sort the underlying list by the given key.
  - query - Supported filter parameters:
  - `created_at`
  - `handle`
  - `title`
  - `updated_at`

See the detailed [search syntax](https://shopify.dev/api/usage/search-syntax)
for more information about using filters.

-}
pages :
    (PagesOptionalArguments -> PagesOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.PageConnection
    -> SelectionSet decodesTo RootQuery
pages fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, after = Absent, last = Absent, before = Absent, reverse = Absent, sortKey = Absent, query = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "reverse" filledInOptionals____.reverse Encode.bool, Argument.optional "sortKey" filledInOptionals____.sortKey (Encode.enum Shopify.Enum.PageSortKeys.toString), Argument.optional "query" filledInOptionals____.query Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "pages" optionalArgs____ object____ Basics.identity


type alias ProductOptionalArguments =
    { id : OptionalArgument Shopify.ScalarCodecs.Id
    , handle : OptionalArgument String
    }


{-| Fetch a specific `Product` by one of its unique attributes.

  - id - The ID of the `Product`.
  - handle - The handle of the `Product`.

-}
product :
    (ProductOptionalArguments -> ProductOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.Product
    -> SelectionSet (Maybe decodesTo) RootQuery
product fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { id = Absent, handle = Absent }

        optionalArgs____ =
            [ Argument.optional "id" filledInOptionals____.id (Shopify.ScalarCodecs.codecs |> Shopify.Scalar.unwrapEncoder .codecId), Argument.optional "handle" filledInOptionals____.handle Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "product" optionalArgs____ object____ (Basics.identity >> Decode.nullable)


type alias ProductByHandleRequiredArguments =
    { handle : String }


{-| Find a product by its handle.

  - handle - The handle of the product.

-}
productByHandle :
    ProductByHandleRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.Product
    -> SelectionSet (Maybe decodesTo) RootQuery
productByHandle requiredArgs____ object____ =
    Object.selectionForCompositeField "productByHandle" [ Argument.required "handle" requiredArgs____.handle Encode.string ] object____ (Basics.identity >> Decode.nullable)


type alias ProductRecommendationsRequiredArguments =
    { productId : Shopify.ScalarCodecs.Id }


{-| Find recommended products related to a given `product_id`.
To learn more about how recommendations are generated, see
[_Showing product recommendations on product pages_](https://help.shopify.com/themes/development/recommended-products).

  - productId - The id of the product.

-}
productRecommendations :
    ProductRecommendationsRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.Product
    -> SelectionSet (Maybe (List decodesTo)) RootQuery
productRecommendations requiredArgs____ object____ =
    Object.selectionForCompositeField "productRecommendations" [ Argument.required "productId" requiredArgs____.productId (Shopify.ScalarCodecs.codecs |> Shopify.Scalar.unwrapEncoder .codecId) ] object____ (Basics.identity >> Decode.list >> Decode.nullable)


type alias ProductTagsRequiredArguments =
    { first : Int }


{-| Tags added to products.
Additional access scope required: unauthenticated\_read\_product\_tags.

  - first - Returns up to the first `n` elements from the list.

-}
productTags :
    ProductTagsRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.StringConnection
    -> SelectionSet decodesTo RootQuery
productTags requiredArgs____ object____ =
    Object.selectionForCompositeField "productTags" [ Argument.required "first" requiredArgs____.first Encode.int ] object____ Basics.identity


type alias ProductTypesRequiredArguments =
    { first : Int }


{-| List of product types for the shop's products that are published to your app.

  - first - Returns up to the first `n` elements from the list.

-}
productTypes :
    ProductTypesRequiredArguments
    -> SelectionSet decodesTo Shopify.Object.StringConnection
    -> SelectionSet decodesTo RootQuery
productTypes requiredArgs____ object____ =
    Object.selectionForCompositeField "productTypes" [ Argument.required "first" requiredArgs____.first Encode.int ] object____ Basics.identity


type alias ProductsOptionalArguments =
    { first : OptionalArgument Int
    , after : OptionalArgument String
    , last : OptionalArgument Int
    , before : OptionalArgument String
    , reverse : OptionalArgument Bool
    , sortKey : OptionalArgument Shopify.Enum.ProductSortKeys.ProductSortKeys
    , query : OptionalArgument String
    }


{-| List of the shopâ€™s products.

  - first - Returns up to the first `n` elements from the list.
  - after - Returns the elements that come after the specified cursor.
  - last - Returns up to the last `n` elements from the list.
  - before - Returns the elements that come before the specified cursor.
  - reverse - Reverse the order of the underlying list.
  - sortKey - Sort the underlying list by the given key.
  - query - Supported filter parameters:
  - `available_for_sale`
  - `created_at`
  - `product_type`
  - `tag`
  - `tag_not`
  - `title`
  - `updated_at`
  - `variants.price`
  - `vendor`

See the detailed [search syntax](https://shopify.dev/api/usage/search-syntax)
for more information about using filters.

-}
products :
    (ProductsOptionalArguments -> ProductsOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.ProductConnection
    -> SelectionSet decodesTo RootQuery
products fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, after = Absent, last = Absent, before = Absent, reverse = Absent, sortKey = Absent, query = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "reverse" filledInOptionals____.reverse Encode.bool, Argument.optional "sortKey" filledInOptionals____.sortKey (Encode.enum Shopify.Enum.ProductSortKeys.toString), Argument.optional "query" filledInOptionals____.query Encode.string ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "products" optionalArgs____ object____ Basics.identity


{-| The list of public Storefront API versions, including supported, release candidate and unstable versions.
-}
publicApiVersions :
    SelectionSet decodesTo Shopify.Object.ApiVersion
    -> SelectionSet (List decodesTo) RootQuery
publicApiVersions object____ =
    Object.selectionForCompositeField "publicApiVersions" [] object____ (Basics.identity >> Decode.list)


{-| The shop associated with the storefront access token.
-}
shop :
    SelectionSet decodesTo Shopify.Object.Shop
    -> SelectionSet decodesTo RootQuery
shop object____ =
    Object.selectionForCompositeField "shop" [] object____ Basics.identity


type alias UrlRedirectsOptionalArguments =
    { first : OptionalArgument Int
    , after : OptionalArgument String
    , last : OptionalArgument Int
    , before : OptionalArgument String
    , reverse : OptionalArgument Bool
    }


{-| A list of redirects for a shop.

  - first - Returns up to the first `n` elements from the list.
  - after - Returns the elements that come after the specified cursor.
  - last - Returns up to the last `n` elements from the list.
  - before - Returns the elements that come before the specified cursor.
  - reverse - Reverse the order of the underlying list.

-}
urlRedirects :
    (UrlRedirectsOptionalArguments -> UrlRedirectsOptionalArguments)
    -> SelectionSet decodesTo Shopify.Object.UrlRedirectConnection
    -> SelectionSet decodesTo RootQuery
urlRedirects fillInOptionals____ object____ =
    let
        filledInOptionals____ =
            fillInOptionals____ { first = Absent, after = Absent, last = Absent, before = Absent, reverse = Absent }

        optionalArgs____ =
            [ Argument.optional "first" filledInOptionals____.first Encode.int, Argument.optional "after" filledInOptionals____.after Encode.string, Argument.optional "last" filledInOptionals____.last Encode.int, Argument.optional "before" filledInOptionals____.before Encode.string, Argument.optional "reverse" filledInOptionals____.reverse Encode.bool ]
                |> List.filterMap Basics.identity
    in
    Object.selectionForCompositeField "urlRedirects" optionalArgs____ object____ Basics.identity
